#+TITLE: EDX How to Code: Simple Data
#+ROAM_KEY: https://www.edx.org/course/how-to-code-simple-data
#+ROAM_TAGS: "computer science" data functions

- tags :: [[file:20200526214234-computer_science.org][computer science]], [[file:20200805181814-data_types.org][data types]],

* Purpose
** Learn how to read and right in programs in terms of higher level desgin structures
** learn systematic program design methods
* Welcome
** Why is it hard to write programs?
   All this is about the Design MEthod:

A program is usually a poorly formed problem. Vague or incomplete task description.
SO you gotta figure out what you want your program to do.
So design method helps us figure that out.
Also, we need to manage progrem complexity.
Also, how to break the program down into smaller well chosen smaller pieces.
And then we write one part of the program for each peice of the problem.
Because of the dseign method, we fit the pieces together well and is well tested.
Then the program is easy to read and easy to modify.
** Think poorly formed problem -> well designed program
** To do well in this course:
1. Program design is learned by doing.
   Type and watch
   Try to rework lecture problemso n your own from scratch after a lectur
   Work on practic e problems from scratch before looking at he solution.
2. Don't worry about making mistakes
* Beginning student language (8 lectures, 5-8 hours)
    :LOGBOOK:
    CLOCK: [2020-10-18 Sun 10:00]--[2020-10-18 Sun 12:00] =>  2:00
  :END:
  Learn to program with the core of the programming language used throughout the course.
** Expressions
*** To form an expression
    (+ 3 4)
(+ 3 ( * 23))
(/ 12 (* 2 3 ))
*** Semicolons are comments
    ;(+3 4)
*** Got sqrs too
    (sqr 3)
    (sqrt 3)
* How to Design Functions (HtDF) Recipe (6 lectures, 4-7 hours)
  :LOGBOOK:
  CLOCK: [2020-11-01 Sun 19:56]--[2020-11-01 Sun 19:57] =>  0:01
  CLOCK: [2020-10-31 Sat 20:49]--[2020-10-31 Sat 21:17] =>  0:28
  :END:
  Learn to use the HtDF recipe to design fucntions that consume simple primitive data.
** Goals
*** Be able to use the How to Design Function (HtDF) recipe to design fucntions that operate on primitive data
*** Be able to read a complete function design and identify its different elements
*** Be able to evaluate the different elements for clarity, simplicikty, and consistency with eachother
*** Be able to eavaluate the entier design for how well it solves the given problem
** HtDF recipe
*** Definition
    Systemizes the design of a function
    Tells us how to define a function
    And helps us define a high-quality function
*** Makes hard problems easier
**** But it can make easier functions harder, or more cumbersome, to design
*** The recipe:
**** Signature, purpose, stub
     The signature says what the function consumes and produces

;; Number -> Number
   ^Consumes  ^ Produces

     The purpose is a 1 line description of what the function produces in terms of what it consumes
     The purpose has to say more than just the signature

;; produce 2 times the given number

     The stub is a code function definition that has the correct function name, has correct number
     of parameters, and produces dummy result of the correct time

(define (double n) 0)
***** Signature should be most specific as possible
****** I.e. are you sure you don't just mean Number, but mean Natural Number?
****** Sounds like good practice for type checking too

**** Examples (wrapped in check-expect)
     The examples help us understand what a function must do. Multiple examples to illustrate behavior.
     If you do an example right, it also functions as a unit test.

(check-expect (double 3) 6)
(check-expect (double 4.2) 8.4)

     Having a good stub early in this process means you can run the tests right away and make sure
     that they're well formed.

**** Inventory - template and constants
     The body of the template is the outline of the function
     For now the body of the template is (...x) where x is the parameter to the function

(define (double n) ;this is the template
  (... n))

     The ... means "do something"
**** Code Body
     Use everything from before to write this

(define (double n)
  (* 2 n))

**** Test and debug
***** How many tests is enough?
****** After running all tests, all code should have been run, at least
****** "Code Coverage"
*** Example problem:
    Design a function that consumes a number and produces twice that number.

    Number -> Number                    // Signature
    // product 2 times the given number // purpose
    (define (double n) 0)               // stub

    Examples / tests:
    (check-expect (double 3) 6)
    (check-expect (double 4.2) 8.4)

    Template:
    (define (double n))
*** Test
**** First HtDF Problem
 Problem: Design a function that pluralizes a given word.
(Pluralize means to convert the word to its plural form.)
For simplicity you may assume that just adding s is enough to pluralize a word.

;Signature
;; String -> String

;Purpose
;;Produce the given string with an "s" attached

;Stub
(define (plural n) 'butt')

; Examples
(check-expect (plural 'cat') 'cats')
(check-expect (plural 'dogs) 'dogss)

; Template
;; (define (plural n)
;;  (... n))

; Code Body

(define (plural n)
    (+ n "s"))
*** Practice Problems
**** Less than 5
     Design a problem to check if the length of a string is less than 5.

Signature
; String -> Boolean

Purpose
; Determine if the string's length is less than 5

Stub
(define (isLessThanFive x) false)

Examples
(check-expect (isLessThanFive ('cat')) true)
(check-expect (isLessThanFive ('banana')) false)
(check-expect (isLessThanFive ('hello)) false)

Inventory
(define (isLessThanFive)
  if (...isLessThanFive)
  true
  false
)

Code Body

(define (isLessThanFive x)
  ( < 5 x )
)

* How to Design Data (HtDD) Recipe (12 lectures, 5-8 hours)
  :PROPERTIES:
  :Effort:   5:00
  :END:
  :LOGBOOK:
  CLOCK: [2021-01-18 Mon 10:14]--[2021-01-18 Mon 12:07] =>  1:53
  CLOCK: [2020-12-24 Thu 12:21]--[2020-12-24 Thu 12:48] =>  0:27
  CLOCK: [2020-11-01 Sun 19:57]--[2020-11-01 Sun 20:09] =>  0:12
  CLOCK: [2020-08-05 Wed 18:19]--[2020-08-05 Wed 18:45] =>  0:26
  CLOCK: [2020-08-04 Tue 20:27]--[2020-08-04 Tue 20:33] =>  0:06
  CLOCK: [2020-08-04 Tue 17:43]--[2020-08-04 Tue 18:00] =>  0:17
  CLOCK: [2020-08-04 Tue 17:02]--[2020-08-04 Tue 17:09] =>  0:07
  CLOCK: [2020-08-03 Mon 19:47]--[2020-08-03 Mon 20:17] =>  0:30
  CLOCK: [2020-07-27 Mon 17:51]--[2020-07-27 Mon 18:02] =>  0:11
  CLOCK: [2020-07-27 Mon 17:19]--[2020-07-27 Mon 17:23] =>  0:04
  :END:
  Learn to use the HtDD recipe to design data definitions for atomic data.
** Goals
*** be able to use the How to Design Data Definitions HtDD recipe
**** to define data definitions for atomic data
*** identify how problem domain information should be represented
**** simple atomic data
***** data that can no longer be broken down into smaller units
**** intervals
**** enumerations
**** itemizations
**** mixed data itemizations
*** use data driven templates recipe to generate templates for functions
*** use how to design functions HtDF recipe to design functions
** Data Definitions
   Data definitions explain how information is represented as data.
   This is a crucial part of program design and has a significant
     effect on the design of every function that operates on that data.
*** Problem Domain
    Imagine a traffic simulation function
    The function alone doesn't say much

(define (next-color c)
  (cond [(= c 0) 2]
        [(= c 1) 0]
        [(= c 2) 1]))

   Technically what it does is tell you what color to show next.
   That's not clear. If they use the HtDF recipe it's more clear


;;Part of a traffic simulation

;; Natural -> Natural
;; product next color of traffic light

(check-expect (next-color 0) 2)
(check-expect (next-color 1) 0)
(check-expect (next-color 2) 1)

;(define (next-color c) 0) ;stub

;(define (next-color c) ;template
;  (...c))

(define (next-color c)
  (cond [(= c 0) 2]
        [(= c 1) 0]
        [(= c 2) 1]))

   While we know it expects a Natural, what this doesn't show is that
     the function also expects only 0, 1, 2. 3 would be wrong because
     it doesn't represent a color. Also, we're not exactly sure what
     the 0, 1, 2, represent. We need more.
**** The problem domain represents things in the program
     Problem Domain                  program
       "a light is red"                 0
**** We represent information in the problem domain using data in the program
**** we interpret data in the program as information in the problem domain
**** Data definition tells you everything you need to know about representing information as data
**** Changes the HtDF recipe by adding type definitions

;; Data definitions
;; TLColor is one of:
;; - 0
;; - 1
;; - 2
;; interp. color of a traffic light - 0 is red, 1 yelllow, 2 green
#;
(define (fn-for-tlcolor c)
  (cond [(= c 0) (...)]
        [(= c 1) (...)]
        [(= c 2) (...)]))

;; FUnctions:

;; TLColor -> TLcolor
;; product next color of traffic light
(check-expect (next-color 0) 2)
(check-expect (next-color 1) 0)
(check-expect (next-color 2) 1)

;(define (next-color c) 0) ;stub

; Template from TLColor

(define (next-color c)
  (cond [(= c 0) 2]
        [(= c 1) 0]
        [(= c 2) 1]))
**** Data Definition describes
***** How to form data of a new type
***** how to represent information as data
***** how to interpret data as information
***** template for operating on data
**** Data definition simplifies function
***** restricts data consumed
***** restricts data produced
***** helps generate examples
***** provides template
** Atomic non-distinct - how to design a Data Recipe
*** Data definition Recipe:
**** 1. A possible *structure definition*
**** 2. a *type comment* that defines a new type name and describes how to form data
**** 3. An *interpretation* that describes the correspondence between information and data
**** 4. One or more *examples* of the data
**** 5. A *template* for a 1 argument function operating on data of this type
*** First thing to do is work out the form of the data we're trying to represent
    We're trying to represent city names
    But these city names are atomic - they can't be broken down any further
**** atomic information should be represented as a type
     :PROPERTIES:
     :ORDERED:  t
     :END:
     ;;  CityName is String
     ;; interp. the name of a city
     (define CN1 "Boston")
     (define CN2 "Vancouver")
**** template:
     (define (fn-for-city-name cn)
       (...cn)
     )
     ;; Template rules used:
     ;; Atomic non-distinct: string
***** this all comes from some kind of table they have with data types on one side, and template format on right
** HtDF With Non-Primitive Data
*** Now, use above data definition to design a function that produces `true` if a given city is best
    ;; Function recipe:
    ;; Functions:
    ;; CityName -> Boolean
    ;; produce true if the given city is best in the world
    (check-expect (best? "Boston") false)
    (check-expect (best? "Hogsmeade") true)

    (define (best? cn) false) ;stub

    ;took template from CityName
    (define (fn-for-city-name cn)
      (if (string=? cn "Hogsmeade")
      true
      false
      )
     )

    Sometimes your code is more cumbersome when you write it this way.
    Just return string=? cn "Hogsmeade"
** HtDF X Structure of Data Orthogonality
*** HtDF and HtDD recipes are orthogonal - HtDF Works the same for all forms of data
**** There are other types of data:
***** atomic
****** CityName
***** distinct
****** false
***** interval
****** SeatNum
***** enumeration
****** TrafficLightColor
****** LetterGrade
***** itemization
****** CountDown
**** No matter what HtDF works the same way for all those kinds of data
*** Working with a systemic design process means you always know what to do next
*** Plus you write readable consistent code that's well tested
** Interval Data Definitions
*** used for information that is numbers within a certain range
    Problem:
    Imagine that you are desigining a program to manage ticket sales for a theater that is
    perfectly rectangular in shape.
    Design a data definition to represent a seat number in a row, where each row has 32
    seats. Just the seat number, not the row number.

    So a seat number will be a number like 1, 2, 3.... all the way up to 32
*** Here's what an interval data definition looks like:
    ;; SeatNum is Natural[1, 32]
    Say name of the value, its type, then it's (range) exclusive
    Meanwhile [] inclusive. They can be mixed and matched.
    ;; interp. seat numbers in a row, 1 and 32 are aisle seats
    That's the correspondence between information and data, the interpretation
    Include anytyhing that could help understand data

    Examples:
    (define SN1 1) ;aisle
    (define SN2 12) ;middle
    (define SN1 32) ;aisle

    Template:
    (define (fn-for-seat-num)
      (... sn)
    )

    ; Template rules used:
    ; - atomic non-distinct: Natural(1, 32)
** Enumeration Data Definition
*** used when the information to be represented consists of two or more *distinct* values
    Problem:
    As part of desigining a system to keep track of student grades, you are asked to design a data
    definition to represent the letter grade ina  course, which is one of A, B, or C.
    ; A, B, and C are all distinct values

    Type comment:
    ;; LeterGrade is one of:
    ;; - "A"
    ;; - "B"
    ;; - "C"
    ;; interp. the letter grade in a course
    ;; examples are redundant for enumerations

    Template:
    (define (fn-for-letter-grade lg)
    (cond [(string=? lg "A" (...)]
          [(string=? lg "B" (...)]
          [(string=? lg "C" (...)]))

    ;;Template rules used:
    ;; - one of: 3 cases
    ;; atomic distinct value: "A"
    ;; atomic distinct value: "B"
    ;; atomic distinct value: "C"
** Itemization Data Definition
*** used for information comprised of 2 or more categories, at least one of which is *non-distinct*
    Problem:
    Consider desiging the system for controlling a new year's eve display. Design a adata definition to
    represent the current state of the countdown, which falls into one of three categories:
    * not yet started - distinct
    * from 10 to 1 seconds before midnight - different values
    * complete (happy new year!) - distinct

      Type comment:
      ;; CountDown is one of:
      ;; - false
      ;; - Natural[1, 10]
      ;; - "complete"

      ;; interp
      ;; false means countdown has not yet started
      ;; Natural[1, 10] means countdown is running and how many seconds left
      ;; "complete" means countdown is over

      Examples:
      (define CD1 false)
      (define CD2 10) ; just started running
      (define CD3 1) ;almost over
      (define CD4 "complete")

      Template:
      (define (fn-for-countdown c)
      (cond [(false? c) (...)]
      ;; have to be careful with <= because it's mixed data itemization
      ;; have to guard eht <= being called with non number
            [(and (number? c) (<= 1 c) (<= c 10)) (...c)]
            [else (...)]))
      ;; we can use else because in this course you can assume that a function
      ;; is called with arguments that match it's signature
      ;; some programming languages enforce this automatically (huh so
      ;; typescript can be useful lol)

      ;; Template rules used:
      cond with one subclass per subclass of the "one of"
      ;; - one of: 3 cases
      ;; - atomic distinct: false
      ;; - atomic non-distinct: Natural[1, 10]
      ;; - atomic distinct: "complete"
*** Often requires a "guard" (see `(and number? c)` above) to ensure operations don't happen on improper data type
**** this allows an optimization:
       (define (fn-for-countdown c)
         (cond [(false? c) (...)]
               [(number? c) (...c)]
               [else (...)]))
       ;; There's only one Number type in the function's signature, so we know if it's a number,
       ;; we don't have to check to see if it's between 1-10, we can just do whatever
       ;; we need to do to numbers there

*** Can always put "else" for last case of itemization
*** Common simplifications:
**** If a given subclass is the last subclass of its type, we can reduce the test to just the guard, i.e. (number? c)
**** If all remaining subclasses are of the same type, then we can eliminate all of the guards
** HtDF with Interval
*** a function that consumes an interval type, aka non-primitive data, aka data you define
     Problem:
    Imagine that you are desigining a program to manage ticket sales for a theater that is
    perfectly rectangular in shape.
    Design a data definition to represent a seat number in a row, where each row has 32
    seats. Just the seat number, not the row number.

    So a seat number will be a number like 1, 2, 3.... all the way up to 32
    ;; SeatNum is Natural[1, 32]
    Say name of the value, its type, then it's (range) exclusive
    Meanwhile [] inclusive. They can be mixed and matched.
    ;; interp. seat numbers in a row, 1 and 32 are aisle seats
    That's the correspondence between information and data, the interpretation
    Include anytyhing that could help understand data

    Examples:
    (define SN1 1) ;aisle
    (define SN2 12) ;middle
    (define SN1 32) ;aisle

    Template:
    (define (fn-for-seat-num)
      (... sn)
    )

    ; Template rules used:
    ; - atomic non-distinct: Natural(1, 32)

    ;; Functions:

    ;; SeatNum -> Boolean
    ;; produce true if the given seat number is on the aisle
    (check-expect (aisle? 1) true)
    (check-expect (aisle? 16) false)
    (check-expect (aisle? 32) true)

    (define (aisle? sn) false) ;stub

    ; use template from SeatNum

    (define (asile? sn)
      (or (= sn 1)
          (= sn 32)))
** HtDF with Enumeration
   Problem:
   Using the LetterGrade data definition below design a function that
   consumes a letter grade and produces the next highest letter grade.
   Call your function bump-up.

   ;; Data Definitions:
   ;; LetterGrade is one of:
   ;; - "A"
   ;; - "B"
   ;; - "C"
   ;; interp. the letter grade in a course
   ;; <examples are redundant for enumerations>

    Template:
    (define (fn-for-letter-grade lg)
    (cond [(string=? lg "A" (...)]
          [(string=? lg "B" (...)]
          [(string=? lg "C" (...)]))

    ;;Template rules used:
    ;; - one of: 3 cases
    ;; atomic distinct value: "A"
    ;; atomic distinct value: "B"
    ;; atomic distinct value: "C"

    ;; Functions:
    ;; LetterGrade -> LetterGrade
    ;; produce next highest letter grade (no change for A)
    (check-expect (bump-up "A") "A")
    (check-expect (bump-up "B") "A")
    (check-expect (bump-up "C") "B")

    ;(define (bump-up lg) "A") ;stub

    ;use template from LetterGrade
    (define (fn-for-letter-grade lg)
    (cond [(string=? lg "A") "A"]
          [(string=? lg "B") "A"]
          [(string=? lg "C") "B"]))
*** example enumeration problem 2:
    ;; Season is one of:
    ;; - "spring"
    ;; - "summer"
    ;; - "fall"
    ;; - "winter"
    ;; interp. the four seasons of the year
    ;; <examples are redundant for enumerations>

    (define (fn-for-season s)
      (cond [(string=? "spring" s) (...)]
            [(string=? "summer" s) (...)]
            [(string=? "fall" s) (...)]
            [(string=? "winter" s) (...)]))

    ;; Template Rules used:
    ;; - one of: 4 cases
    ;; - atomic distinct: "spring"
    ;; - atomic distinct: "summer"
    ;; - atomic distinct: "fall"
    ;; - atomic distinct: "winter"

    ;; Functions:
    (define (next-season s)
      (cond [(string=? "spring" s) "summer"]
            [(string=? "summer" s) "fall"]
            [(string=? "fall" s) "winter"]
            [(string=? "winter" s) "spring"]))

** HtDF with Itemization
*** Itemizations are used for information comprised of 2 or more categories, at least one of which is non-distinct
         Type comment:
      ;; CountDown is one of:
      ;; - false
      ;; - Natural[1, 10]
      ;; - "complete"

      ;; interp
      ;; false means countdown has not yet started
      ;; Natural[1, 10] means countdown is running and how many seconds left
      ;; "complete" means countdown is over

      Examples:
      (define CD1 false)
      (define CD2 10) ; just started running
      (define CD3 1) ;almost over
      (define CD4 "complete")

      Template:
      (define (fn-for-countdown c)
      (cond [(false? c) (...)]
      ;; have to be careful with <= because it's mixed data itemization
      ;; have to guard eht <= being called with non number
            [(and (number? c) (<= 1 c) (<= c 10)) (...c)]
            [else (...)]))
      ;; we can use else because in this course you can assume that a function
      ;; is called with arguments that match it's signature
      ;; some programming languages enforce this automatically (huh so
      ;; typescript can be useful lol)

      ;; Template rules used:
      cond with one subclass per subclass of the "one of"
      ;; - one of: 3 cases
      ;; - atomic distinct: false
      ;; - atomic non-distinct: Natural[1, 10]
      ;; - atomic distinct: "complete"

      ;; Functions:
      ;; Countdown -> Image
      ;; produce nice image of current state of countdown
      (check-expect (countdown-to-image false) (square 0 "solid" "white"))
      (check-expect (countdown-to-image 5) (text (number->string 5) 24 "black"))
      (check-expect (countdown-to-image "complete") (text "Happy New Year!!!" 24 "red"))

      (define (countdown-to-image c) (square 0 "solid" "white")) ;stub

      ;<use template from Countdown>
      (define (countdown-to-image c)
      (cond [(false? c) (square 0 "solid" "white")]
            [(and (number? c) (<= 1 c) (<= c 10)) (text (number->string c) 24 "black")]
            [else (text "Happy New Year!!!" 24 "red")]))


* How to Design Worlds (HtDW) Recipe (7 lectures, 3-5 hours)
  :PROPERTIES:
  :Effort:   3:00
  :END:
  :LOGBOOK:
  CLOCK: [2021-02-24 Wed 15:43]--[2021-02-24 Wed 16:11] =>  0:28
  CLOCK: [2020-08-25 Tue 18:34]--[2020-08-25 Tue 18:58] =>  0:24
  CLOCK: [2020-08-19 Wed 19:06]--[2020-08-19 Wed 19:12] =>  0:06
  CLOCK: [2020-08-18 Tue 14:54]--[2020-08-18 Tue 15:07] =>  0:13
  CLOCK: [2020-08-17 Mon 20:02]--[2020-08-17 Mon 20:04] =>  0:02
  CLOCK: [2020-08-17 Mon 19:43]--[2020-08-17 Mon 19:55] =>  0:12
  CLOCK: [2020-08-12 Wed 18:22]--[2020-08-12 Wed 18:43] =>  0:21
  :END:
  Leanr how to use the HtDW recipe to design interactive programs with atomic world state

** Overview
   Learn how to design interactive programs that use... drracket big bang functionality?
   Stuff like simple animations
   Also basic techniques for systemiatizing work on larger programs.
   Complemented by the Compound module (next) which will let us create more complex data definitions
   Apparently some of the videos are hella long
*** Learning goals
**** be able to explain the inherent structure of interactive graphical programs
**** be able to use the How to Design Worlds HtDW recipe to design interactive programs with atomic world state.
**** Be able to read and write big-bang expressions.
** Interactive Programs
*** will learn how to design simple interactive programs
    plain graphics but core structures will be like that of more sophisticated versions of the same program
**** animations
**** games
**** desktop applications
** The Big Bang Mechanism
   The inherent behind the scenes functionality of interactive programs
   The big-bang primitive
*** Big bang is a mechanism that supports interactive programs
*** Example programs
**** count down from 10 program, resets on space bar
***** changing state
****** the number on the screen
****** image displaying the number
****** both "tick" once per second
***** changing display
***** keyboard or mouse affects behavior
**** Cat moving left to right, resets on space bar
***** x position changes, thus position of cat image changes
***** Data:
****** numbers representing psoition of cat
       Cat is a number
       Interpret number to be x coordinate of a cat
       Simple Atomic Data
       Two functions:
       render-cat: takes a cat and returns an image of the cat at the appropriate position on the background
       next-cat: takes us from one cat to the next cat, in other words, advances cat's x position by 3

       0 (render-cat 0) (next-cat 0)
       3 (render-cat 3) (next-cat 3)
       6 (render-cat 6) (next-cat 6)
       9 (render-cat 9) (next-cat 9)
       To wire expresions together like this, dr racket uses big-bang expression
       Need an expression that evaluates to initial world state

       (big-bang 0              ; Cat
         (on-tick next-cat)     ; Cat -> Cat
         (to-draw render-cat))  ; Cat -> Image

       big-bang is [[file:20200817194436-polymorphic.org][polymorphic]]: works for any type of world state
       It's a user interface framework - a tool that integrates a bunch of functionality together to get a UI
** Domain analysis
   We about to get into the How to Design Worlds recipe
   Analysis which happens with pencil and paper
   Only then do we get into code
*** Interactive program problem
    Problem: how to Design Worlds recipe to design a cat walking across the page problem?

    Domain Analysis:
      1.a. Sketch program scenarioes

        (cat drawing 1) cat on left of screen
        (cat drawing 2) cat in middle of screen
        (cat drawing 3) cat on right side of string

      1.b. identify constant information

        width (of screen)
        height (of screen)
        ctr-y center of screen y
        mts image of screen
        cat image

      1.c. identify changing information

        x coordinate of cat

      1.d. identify big bang options

        on-tick because the cat position changes all the time
        to-draw to draw the cat every time it changes position

**** World Program Design
     Divided into two parts
***** 1. Domain Analysis (use a piece of paper)
****** 1.a sketch program scenarios
****** 1.b identify constant information
****** 1.c Identify changing information
****** 1.d Identify big-bang options
***** 2. Build the actual program
****** 2.a Constants (based on 1.b)
****** 2.b Data definition using HtDD (based on 1.c)
****** 2.c Functions using HtDF
******* 2.c.1 Main first (based on 1.c, 1.d, and 2.b)
******* 2.c.2 wish list entries for big-bang handlers
****** 2.d Work through wish list until done
** Program through main Function
*** templates
    Before i start on this program, what do i know about the basic structure before i get the details?
    Given that I'm using this basic kind of algorithm, what must be true about the basic structure of the program
      before I get into the details?
**** example template for cat problem
     ;; A cat that walks from left to right across the screen.

     ;; =====
     ;; constants: (comes straight from analysis, done earlier)

     (define WIDTH 600)
     (define HEIGHT 400)

     ;; Always use constants
     (define CTR-Y (/ HEIGHT 2))

     (define MTS (empty-scene WIDTH HEIGHT))

     ;; in the video he pasted an image straight here lol
     (define CAT_IMG pasted_image)

     ;; now do changing variables
     ;; also known as Data Definitions

     ;; ====
     ;; Data Definitions:

     ;; Cat is Number
     ;; interp. x position of the cat in screen coordinates

     ;examples
     (define C1 0) ;left edge
     (define C2 (/ WIDTH 2)) ;middle
     (define C3 WIDTH) ;right edge

     ;template

     (define (fn-for-cat c)
       (... c))

     ;; Template rules used:
     ;; - atomic non-distinct: Number

     ;; =====
     ;; Functions:

     ;; Cat -> Cat
     ;; start the world with....
     ;;
     (define (main c)
       (big-bang c ; Cat
         (on-tick advance-cat) ; Cat -> Cat
         (to-draw render)) ; Cat -> Image

     ;; Cat -> Cat
     ;; produce the next, by advancing it 1 pixel to right
     ;; !!!
     (define (advance-cat c) 0)

     ;; Cat -> Image
     ;; render the cat image at appropriate place on MTS
     ;; !!!
     (define (render c) MTS)


***** Traceability: you can look at analysis and look at code and understand where everything in the analysis showed up in the code
***** Being easy to change is one of the most important properties for a program to have
***** Wish List Entry: a signature, purpose, !!!, and stub
      A promise to come back and finish the function later
      Bigger programs might have 10s or 100s of pending wish list entries
      Be disciplined about writing these in
      !!! is probably what we would call TODO, he searches across the file for !!! to find things to work on
** Working through the wish list
   Completing the world program involves systematically going through the wish list and completing
   the design of everyh "wished-for" function
*** use the wishlist mechanism to keep track of what needs to be done
    starts out looking like:
    ;; Cat -> Cat
     ;; produce the next, by advancing it 1 pixel to right
     ;; !!!
     (define (advance-cat c) 0)

     ;; Cat -> Image
     ;; render the cat image at appropriate place on MTS
     ;; !!!
     (define (render c) MTS)

     Search for "!!!" to find out what to work on next

     ;; Cat -> Cat
     ;; produce the next, by advancing it 1 pixel to right
     (check-expect (advance-cat 3) 4)
     ;(define (advance-cat c) 0)

     ; <use template from Cat>
     (define (advance-cat c)
       (+ c 1))
** Improving a world program - add SPEED
   Mostly just an another example of using HtDF and HtDW
*** the previous analysis is a model of the program
    Add the speed constant

    (define SPEED 3)
    The analysis lets us know we also need to look at the on-tick handler

    We can see that it invokes advance-cat, the function we need to change
*** Making a good model lets us change by thinking at the model level
    This is the difference between program designers and people who write code that just happens to work
    wow ok personal attack there lol
** Improving a world program - add key handler
   Mostly review. New Material: testing and templating functions that operate on large enumerations
*** Adding the on-key handler
    No need to make a chagne to the constants or changing, but we do add it to the big bang options

    ;; =====
     ;; Functions:

     ;; Cat -> Cat
     ;; start the world with....
     ;;
     (define (main c)
       (big-bang c ; Cat
         (on-tick advance-cat) ; Cat -> Cat
         (to-draw render) ; Cat -> Image
         (on-key handle-key))) ; Cat KeyEvent -> Cat

     ;; This function doesn't exist yet, so add a wishlist entry!
     ;; Grab the signature

     ;; Cat KeyEvent -> Cat
     ;; reset cat to left edge when space key is pressed
     ;; !!!
     (define (handle-key c key) 0) ;stub
*** Handling huge enumerations
     ;; Cat KeyEvent -> Cat
     ;; reset cat to left edge when space key is pressed
     ;; !!!
     (check-expect (handle-key 10 " ") 0)
     (check-expect (handle-key 10 "a") 10)
     (check-expect (handle-key 0 " ") 0)
     (check-expect (handle-key 0 "a") 0)
     ;; (define (handle-key c key) 0) ;stub

     ;; It's a very large enumeration, do i need to test all the case?
     ;; Nah, not really, because we kinda know how this will work. But we don't, so we need to template.

     (define (handle-key c ke)
       (cond [(key=? ke " ") (... c)]
             [else
               (... c)]))

     ;; if you followed normal data definition rule, you'd have to cover every single keyboard rule
     ;; if it's a large numeration, we can focus on special cases, and then all the other cases will be handled similarly
     ;; this is called [[file:20200825185450-white_box_testing.org][white box testing]]
     ;; you know the condition has just two cases
     ;; you allow yourself to know something about the structure of the function

* Compound Data (3 lectures, 4-6 hours)
  :PROPERTIES:
  :Effort:   4:00
  :END:
  :LOGBOOK:
  CLOCK: [2020-08-26 Wed 14:59]--[2020-08-26 Wed 15:15] =>  0:16
  CLOCK: [2020-08-25 Tue 18:59]--[2020-08-25 Tue 19:08] =>  0:09
  :END:
  Leanr how to use the HtDW recipe to design interactive programs with compound world state
** Module overview
   Learn how to design [[file:20200825190046-compound_data.org][compound data]] definitions to represent information that consists of two or more
   naturally connected values, as well as how to use such data as world state in HtDW problems.
*** Learning goals
**** be able to identify [[file:20200825190335-domain_information.org][domain information]] that should be represented as [[file:20200825190046-compound_data.org][compound data]]
**** be able to read and write define-struct definitions
**** be able to design functions that consume and/or produce [[file:20200825190046-compound_data.org][compound data]]
**** be able to design world programs that use compound world state
** define-struct
   A new mechanism from the BSL language allows us to build multi-part (or compound) values and later to
   deconstruct the compound values to get the individual values back.

   We've seen other data types previously
   primitive
   interval
   enumeration
   itemization

   In each of thewse cases, a single data value really consists of just one value
   They were [[file:20200825190631-atomic_data.org][atomic]]

   We might want to represent xy position
   or the first AND last name of someone
*** [[file:20200825190046-compound_data.org][compound data]]
    Data that involves pieces of information that naturally belong together
    For example:
      First and Last name of a person
      Name, supervisor, and salary of an employee
      x and y coordinates of something
*** structs
    V structure name V   Vfield namesV
    (define-struct pos (x y))

    This structure will help represent x y positions
    This is a constructor
    Use it like:
    (make-pos 3 6)
    The order of the arguments matter, first to x, second to y
    Thus it is a [[file:20200826150150-boa_constructor.org][boa constructor]]

    (define P1 (make-pos 3 6)) ;; constructors
    (define P2 (make-pos 2 8))

    That puts them together, how do you take them apart?

    (pos-x P1) ;; return 3 ;; selectors
    (pos-y P2) ;; return 8 ;; selectors

    Check if instance of struct
    (pos? P1) ; true
    (pos? 'hello') ; false
** Compound Data Definitions
   How to form compound data definitions using the [[file:20200826150531-htdd.org][HtDD]] recipe

   PROBLEM:
   Design a data definition to represent hockey players, including both their first and last names.
   ;; these are two values that naturally fit together
   ;; thus [[file:20200825190046-compound_data.org][compound data]]

*** data definition:
    1. a possible structure definition

    (define-struct player (fn ln))

    1. a type comment
       ;; Player is (make-player String String)
    2. an interpretation
      ;; interp. (make-player fn ln) is a hockey player with
      ;; ;; fn is the first naame
      ;; ;; ln is the last naame
    3. one or more examples
      (define P1 (make-player "Bobby" "orr"))
      (define P2 (make-player "Wayne" "Noob"))
    4. a template

       (define (fn-for-player p)
         (... (player-fn p)  ;String
              (player-ln p))) ;String

       ;; Template rules used:
       ;; - Compound : 2 fields
       ;; Must work on all fields of the struct
** HtDW With [[file:20200825190046-compound_data.org][Compound Data]]
*** cow animation lol
* Self-reference (7 lectures, 5-7 hours)
  Learn how to use well-formed self-referential data definitions to represent arbitrary sized data.
* Reference (3 lectures, 4-6 horus)
  Learn to predict and identify the correspondence between refercnes in a data definition and helper
function calls in functions that operate on the data
* Naturals (2 lectures, 3-4 horus)
  Design an alternate data defiition for the natural numbers, and learn to write function
using this new data definition
* Helpers (6 lectures, 6-9 hours)
  Learn a set of rules for desigining functions with helper functions
* Binary Search Trees (6 lectures, 5-6 hours)
  Design a data definition for Binary Search Trees, and learn to write functions operating
on BSTs
