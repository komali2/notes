#+TITLE: EDX How to Code: Simple Data
#+ROAM_KEY: https://www.edx.org/course/how-to-code-simple-data

- tags :: [[file:20200526214234-computer_science.org][computer science]], [[file:20200805181814-data_types.org][data types]],

* Purpose
** Learn how to read and right in programs in terms of higher level desgin structures
** learn systematic program design methods
* Welcome
** Why is it hard to write programs?
   All this is about the Design MEthod:

A program is usually a poorly formed problem. Vague or incomplete task description.
SO you gotta figure out what you want your program to do.
So design method helps us figure that out.
Also, we need to manage progrem complexity.
Also, how to break the program down into smaller well chosen smaller pieces.
And then we write one part of the program for each peice of the problem.
Because of the dseign method, we fit the pieces together well and is well tested.
Then the program is easy to read and easy to modify.
** Think poorly formed problem -> well designed program
** To do well in this course:
1. Program design is learned by doing.
   Type and watch
   Try to rework lecture problemso n your own from scratch after a lectur
   Work on practic e problems from scratch before looking at he solution.
2. Don't worry about making mistakes
* Beginning student language (8 lectures, 5-8 hours)
  Learn to program with the core of the programming language used throughout the course.
** Expressions
*** To form an expression
    (+ 3 4)
(+ 3 ( * 23))
(/ 12 (* 2 3 ))
*** Semicolons are comments
    ;(+3 4)
*** Got sqrs too
    (sqr 3)
    (sqrt 3)
* How to Design Functions (HtDF) Recipe (6 lectures, 4-7 hours)
  Learn to use the HtDF recipe to design fucntions that consume simple primitive data.
** Goals
*** Be able to use the How to Design Function (HtDF) recipe to design fucntions that operate on primitive data
*** Be able to read a complete function design and identify its different elements
*** Be able to evaluate the different elements for clarity, simplicikty, and consistency with eachother
*** Be able to eavaluate the entier design for how well it solves the given problem
** HtDF recipe
*** Definition
    Systemizes the design of a function
    Tells us how to define a function
    And helps us define a high-quality function
*** Makes hard problems easier
**** But it can make easier functions harder, or more cumbersome, to design
*** The recipe:
**** Signature, purpose, stub
     The signature says what the function consumes and produces

;; Number -> Number
   ^Consumes  ^ Produces

     The purpose is a 1 line description of what the function produces in terms of what it consumes
     The purpose has to say more than just the signature

;; produce 2 times the given number

     The stub is a code function definition that has the correct function name, has correct number
     of parameters, and produces dummy result of the correct time

(define (double n) 0)
***** Signature should be most specific as possible
****** I.e. are you sure you don't just mean Number, but mean Natural Number?
****** Sounds like good practice for type checking too

**** Examples (wrapped in check-expect)
     The examples help us understand what a function must do. Multiple examples to illustrate behavior.
     If you do an example right, it also functions as a unit test.

(check-expect (double 3) 6)
(check-expect (double 4.2) 8.4)

     Having a good stub early in this process means you can run the tests right away and make sure
     that they're well formed.

**** Inventory - template and constants
     The body of the template is the outline of the function
     For now the body of the template is (...x) where x is the parameter to the function

(define (double n) ;this is the template
  (... n))

     The ... means "do something"
**** Code Body
     Use everything from before to write this

(define (double n)
  (* 2 n))

**** Test and debug
***** How many tests is enough?
****** After running all tests, all code should have been run, at least
****** "Code Coverage"
*** Example problem:
    Design a function that consumes a number and produces twice that number.

    Number -> Number                    // Signature
    // product 2 times the given number // purpose
    (define (double n) 0)               // stub

    Examples / tests:
    (check-expect (double 3) 6)
    (check-expect (double 4.2) 8.4)

    Template:
    (define (double n))
*** Test
**** First HtDF Problem
 Problem: Design a function that pluralizes a given word.
(Pluralize means to convert the word to its plural form.)
For simplicity you may assume that just adding s is enough to pluralize a word.

;Signature
;; String -> String

;Purpose
;;Produce the given string with an "s" attached

;Stub
(define (plural n) 'butt')

; Examples
(check-expect (plural 'cat') 'cats')
(check-expect (plural 'dogs) 'dogss)

; Template
;; (define (plural n)
;;  (... n))

; Code Body

(define (plural n)
    (+ n "s"))
*** Practice Problems
**** Less than 5
     Design a problem to check if the length of a string is less than 5.

Signature
; String -> Boolean

Purpose
; Determine if the string's length is less than 5

Stub
(define (isLessThanFive x) false)

Examples
(check-expect (isLessThanFive ('cat')) true)
(check-expect (isLessThanFive ('banana')) false)
(check-expect (isLessThanFive ('hello)) false)

Inventory
(define (isLessThanFive)
  if (...isLessThanFive)
  true
  false
)

Code Body

(define (isLessThanFive x)
  ( < 5 x )
)

* How to Design Data (HtDD) Recipe (12 lectures, 5-8 hours)
  :PROPERTIES:
  :Effort:   5:00
  :END:
  :LOGBOOK:
  CLOCK: [2020-08-05 Wed 18:19]--[2020-08-05 Wed 18:45] =>  0:26
  CLOCK: [2020-08-04 Tue 20:27]--[2020-08-04 Tue 20:33] =>  0:06
  CLOCK: [2020-08-04 Tue 17:43]--[2020-08-04 Tue 18:00] =>  0:17
  CLOCK: [2020-08-04 Tue 17:02]--[2020-08-04 Tue 17:09] =>  0:07
  CLOCK: [2020-08-03 Mon 19:47]--[2020-08-03 Mon 20:17] =>  0:30
  CLOCK: [2020-07-27 Mon 17:51]--[2020-07-27 Mon 18:02] =>  0:11
  CLOCK: [2020-07-27 Mon 17:19]--[2020-07-27 Mon 17:23] =>  0:04
  :END:
  Learn to use the HtDD recipe to design data definitions for atomic data.
** Goals
*** be able to use the How to Design Data Definitions HtDD recipe
**** to define data definitions for atomic data
*** identify how problem domain information should be represented
**** simple atomic data
***** data that can no longer be broken down into smaller units
**** intervals
**** enumerations
**** itemizations
**** mixed data itemizations
*** use data driven templates recipe to generate templates for functions
*** use how to design functions HtDF recipe to design functions
** Data Definitions
   Data definitions explain how information is represented as data.
   This is a crucial part of program design and has a significant
     effect on the design of every function that operates on that data.
*** Problem Domain
    Imagine a traffic simulation function
    The function alone doesn't say much

(define (next-color c)
  (cond [(= c 0) 2]
        [(= c 1) 0]
        [(= c 2) 1]))

   Technically what it does is tell you what color to show next.
   That's not clear. If they use the HtDF recipe it's more clear


;;Part of a traffic simulation

;; Natural -> Natural
;; product next color of traffic light

(check-expect (next-color 0) 2)
(check-expect (next-color 1) 0)
(check-expect (next-color 2) 1)

;(define (next-color c) 0) ;stub

;(define (next-color c) ;template
;  (...c))

(define (next-color c)
  (cond [(= c 0) 2]
        [(= c 1) 0]
        [(= c 2) 1]))

   While we know it expects a Natural, what this doesn't show is that
     the function also expects only 0, 1, 2. 3 would be wrong because
     it doesn't represent a color. Also, we're not exactly sure what
     the 0, 1, 2, represent. We need more.
**** The problem domain represents things in the program
     Problem Domain                  program
       "a light is red"                 0
**** We represent information in the problem domain using data in the program
**** we interpret data in the program as information in the problem domain
**** Data definition tells you everything you need to know about representing information as data
**** Changes the HtDF recipe by adding type definitions

;; Data definitions
;; TLColor is one of:
;; - 0
;; - 1
;; - 2
;; interp. color of a traffic light - 0 is red, 1 yelllow, 2 green
#;
(define (fn-for-tlcolor c)
  (cond [(= c 0) (...)]
        [(= c 1) (...)]
        [(= c 2) (...)]))

;; FUnctions:

;; TLColor -> TLcolor
;; product next color of traffic light
(check-expect (next-color 0) 2)
(check-expect (next-color 1) 0)
(check-expect (next-color 2) 1)

;(define (next-color c) 0) ;stub

; Template from TLColor

(define (next-color c)
  (cond [(= c 0) 2]
        [(= c 1) 0]
        [(= c 2) 1]))
**** Data Definition describes
***** How to form data of a new type
***** how to represent information as data
***** how to interpret data as information
***** template for operating on data
**** Data definition simplifies function
***** restricts data consumed
***** restricts data produced
***** helps generate examples
***** provides template
** Atomic non-distinct - how to design a Data Recipe
*** Data definition Recipe:
**** 1. A possible *structure definition*
**** 2. a *type comment* that defines a new type name and describes how to form data
**** 3. An *interpretation* that describes the correspondence between information and data
**** 4. One or more *examples* of the data
**** 5. A *template* for a 1 argument function operating on data of this type
*** First thing to do is work out the form of the data we're trying to represent
    We're trying to represent city names
    But these city names are atomic - they can't be broken down any further
**** atomic information should be represented as a type
     :PROPERTIES:
     :ORDERED:  t
     :END:
     ;;  CityName is String
     ;; interp. the name of a city
     (define CN1 "Boston")
     (define CN2 "Vancouver")
**** template:
     (define (fn-for-city-name cn)
       (...cn)
     )
     ;; Template rules used:
     ;; Atomic non-distinct: string
***** this all comes from some kind of table they have with data types on one side, and template format on right
** HtDF With Non-Primitive Data
*** Now, use above data definition to design a function that produces `true` if a given city is best
    ;; Function recipe:
    ;; Functions:
    ;; CityName -> Boolean
    ;; produce true if the given city is best in the world
    (check-expect (best? "Boston") false)
    (check-expect (best? "Hogsmeade") true)

    (define (best? cn) false) ;stub

    ;took template from CityName
    (define (fn-for-city-name cn)
      (if (string=? cn "Hogsmeade")
      true
      false
      )
     )

    Sometimes your code is more cumbersome when you write it this way.
    Just return string=? cn "Hogsmeade"
** HtDF X Structure of Data Orthogonality
*** HtDF and HtDD recipes are orthogonal - HtDF Works the same for all forms of data
**** There are other types of data:
***** atomic
****** CityName
***** distinct
****** false
***** interval
****** SeatNum
***** enumeration
****** TrafficLightColor
****** LetterGrade
***** itemization
****** CountDown
**** No matter what HtDF works the same way for all those kinds of data
*** Working with a systemic design process means you always know what to do next
*** Plus you write readable consistent code that's well tested
** Interval Data Definitions
*** used for information that is numbers within a certain range
    Problem:
    Imagine that you are desigining a program to manage ticket sales for a theater that is
    perfectly rectangular in shape.
    Design a data definition to represent a seat number in a row, where each row has 32
    seats. Just the seat number, not the row number.

    So a seat number will be a number like 1, 2, 3.... all the way up to 32
*** Here's what an interval data definition looks like:
    ;; SeatNum is Natural[1, 32]
    Say name of the value, its type, then it's (range) exclusive
    Meanwhile [] inclusive. They can be mixed and matched.
    ;; interp. seat numbers in a row, 1 and 32 are aisle seats
    That's the correspondence between information and data, the interpretation
    Include anytyhing that could help understand data

    Examples:
    (define SN1 1) ;aisle
    (define SN2 12) ;middle
    (define SN1 32) ;aisle

    Template:
    (define (fn-for-seat-num)
      (... sn)
    )

    ; Template rules used:
    ; - atomic non-distinct: Natural(1, 32)
** Enumeration Data Definition
*** used when the information to be represented consists of two or more *distinct* values
    Problem:
    As part of desigining a system to keep track of student grades, you are asked to design a data
    definition to represent the letter grade ina  course, which is one of A, B, or C.
    ; A, B, and C are all distinct values

    Type comment:
    ;; LeterGrade is one of:
    ;; - "A"
    ;; - "B"
    ;; - "C"
    ;; interp. the letter grade in a course
    ;; examples are redundant for enumerations

    Template:
    (define (fn-for-letter-grade lg)
    (cond [(string=? lg "A" (...)]
          [(string=? lg "B" (...)]
          [(string=? lg "C" (...)]))

    ;;Template rules used:
    ;; - one of: 3 cases
    ;; atomic distinct value: "A"
    ;; atomic distinct value: "B"
    ;; atomic distinct value: "C"
** Itemization Data Definition
*** used for information comprised of 2 or more categories, at least one of which is *non-distinct*
    Problem:
    Consider desiging the system for controlling a new year's eve display. Design a adata definition to
    represent the current state of the countdown, which falls into one of three categories:
    * not yet started - distinct
    * from 10 to 1 seconds before midnight - different values
    * complete (happy new year!) - distinct

      Type comment:
      ;; CountDown is one of:
      ;; - false
      ;; - Natural[1, 10]
      ;; - "complete"

      ;; interp
      ;; false means countdown has not yet started
      ;; Natural[1, 10] means countdown is running and how many seconds left
      ;; "complete" means countdown is over

      Examples:
      (define CD1 false)
      (define CD2 10) ; just started running
      (define CD3 1) ;almost over
      (define CD4 "complete")

      Template:
      (define (fn-for-countdown c)
      (cond [(false? c) (...)]
      ;; have to be careful with <= because it's mixed data itemization
      ;; have to guard eht <= being called with non number
            [(and (number? c) (<= 1 c) (<= c 10)) (...c)]
            [else (...)]))
      ;; we can use else because in this course you can assume that a function
      ;; is called with arguments that match it's signature
      ;; some programming languages enforce this automatically (huh so
      ;; typescript can be useful lol)

      ;; Template rules used:
      cond with one subclass per subclass of the "one of"
      ;; - one of: 3 cases
      ;; - atomic distinct: false
      ;; - atomic non-distinct: Natural[1, 10]
      ;; - atomic distinct: "complete"
*** Often requires a "guard" (see `(and number? c)` above) to ensure operations don't happen on improper data type
**** this allows an optimization:
       (define (fn-for-countdown c)
         (cond [(false? c) (...)]
               [(number? c) (...c)]
               [else (...)]))
       ;; There's only one Number type in the function's signature, so we know if it's a number,
       ;; we don't have to check to see if it's between 1-10, we can just do whatever
       ;; we need to do to numbers there

*** Can always put "else" for last case of itemization
*** Common simplifications:
**** If a given subclass is the last subclass of its type, we can reduce the test to just the guard, i.e. (number? c)
**** If all remaining subclasses are of the same type, then we can eliminate all of the guards
** HtDF with Interval
*** a function that consumes an interval type, aka non-primitive data, aka data you define
     Problem:
    Imagine that you are desigining a program to manage ticket sales for a theater that is
    perfectly rectangular in shape.
    Design a data definition to represent a seat number in a row, where each row has 32
    seats. Just the seat number, not the row number.

    So a seat number will be a number like 1, 2, 3.... all the way up to 32
    ;; SeatNum is Natural[1, 32]
    Say name of the value, its type, then it's (range) exclusive
    Meanwhile [] inclusive. They can be mixed and matched.
    ;; interp. seat numbers in a row, 1 and 32 are aisle seats
    That's the correspondence between information and data, the interpretation
    Include anytyhing that could help understand data

    Examples:
    (define SN1 1) ;aisle
    (define SN2 12) ;middle
    (define SN1 32) ;aisle

    Template:
    (define (fn-for-seat-num)
      (... sn)
    )

    ; Template rules used:
    ; - atomic non-distinct: Natural(1, 32)

    ;; Functions:

    ;; SeatNum -> Boolean
    ;; produce true if the given seat number is on the aisle
    (check-expect (aisle? 1) true)
    (check-expect (aisle? 16) false)
    (check-expect (aisle? 32) true)

    (define (aisle? sn) false) ;stub

    ; use template from SeatNum

    (define (asile? sn)
      (or (= sn 1)
          (= sn 32)))
** HtDF with Enumeration
   Problem:
   Using the LetterGrade data definition below design a function that
   consumes a letter grade and produces the next highest letter grade.
   Call your function bump-up.

   ;; Data Definitions:
   ;; LetterGrade is one of:
   ;; - "A"
   ;; - "B"
   ;; - "C"
   ;; interp. the letter grade in a course
   ;; <examples are redundant for enumerations>

    Template:
    (define (fn-for-letter-grade lg)
    (cond [(string=? lg "A" (...)]
          [(string=? lg "B" (...)]
          [(string=? lg "C" (...)]))

    ;;Template rules used:
    ;; - one of: 3 cases
    ;; atomic distinct value: "A"
    ;; atomic distinct value: "B"
    ;; atomic distinct value: "C"

    ;; Functions:
    ;; LetterGrade -> LetterGrade
    ;; produce next highest letter grade (no change for A)
    (check-expect (bump-up "A") "A")
    (check-expect (bump-up "B") "A")
    (check-expect (bump-up "C") "B")

    ;(define (bump-up lg) "A") ;stub

    ;use template from LetterGrade
    (define (fn-for-letter-grade lg)
    (cond [(string=? lg "A") "A"]
          [(string=? lg "B") "A"]
          [(string=? lg "C") "B"]))
*** example enumeration problem 2:
    ;; Season is one of:
    ;; - "spring"
    ;; - "summer"
    ;; - "fall"
    ;; - "winter"
    ;; interp. the four seasons of the year
    ;; <examples are redundant for enumerations>

    (define (fn-for-season s)
      (cond [(string=? "spring" s) (...)]
            [(string=? "summer" s) (...)]
            [(string=? "fall" s) (...)]
            [(string=? "winter" s) (...)]))

    ;; Template Rules used:
    ;; - one of: 4 cases
    ;; - atomic distinct: "spring"
    ;; - atomic distinct: "summer"
    ;; - atomic distinct: "fall"
    ;; - atomic distinct: "winter"

    ;; Functions:
    (define (next-season s)
      (cond [(string=? "spring" s) "summer"]
            [(string=? "summer" s) "fall"]
            [(string=? "fall" s) "winter"]
            [(string=? "winter" s) "spring"]))

** HtDF with Itemization
         Type comment:
      ;; CountDown is one of:
      ;; - false
      ;; - Natural[1, 10]
      ;; - "complete"

      ;; interp
      ;; false means countdown has not yet started
      ;; Natural[1, 10] means countdown is running and how many seconds left
      ;; "complete" means countdown is over

      Examples:
      (define CD1 false)
      (define CD2 10) ; just started running
      (define CD3 1) ;almost over
      (define CD4 "complete")

      Template:
      (define (fn-for-countdown c)
      (cond [(false? c) (...)]
      ;; have to be careful with <= because it's mixed data itemization
      ;; have to guard eht <= being called with non number
            [(and (number? c) (<= 1 c) (<= c 10)) (...c)]
            [else (...)]))
      ;; we can use else because in this course you can assume that a function
      ;; is called with arguments that match it's signature
      ;; some programming languages enforce this automatically (huh so
      ;; typescript can be useful lol)

      ;; Template rules used:
      cond with one subclass per subclass of the "one of"
      ;; - one of: 3 cases
      ;; - atomic distinct: false
      ;; - atomic non-distinct: Natural[1, 10]
      ;; - atomic distinct: "complete"

      ;; Functions:
      ;; Countdown -> Image
      ;; produce nice image of current state of countdown
      (check-expect (countdown-to-image false) (square 0 "solid" "white"))
      (check-expect (countdown-to-image 5) (text (number->string 5) 24 "black"))
      (check-expect (countdown-to-image "complete") (text "Happy New Year!!!" 24 "red"))

      (define (countdown-to-image c) (square 0 "solid" "white")) ;stub

      ;<use template from Countdown>
      (define (countdown-to-image c)
      (cond [(false? c) (square 0 "solid" "white")]
            [(and (number? c) (<= 1 c) (<= c 10)) (text (number->string c) 24 "black")]
            [else (text "Happy New Year!!!" 24 "red")]))

* How to Design Worlds (HtDW) Recipe (7 lectures, 3-5 hours)
  :PROPERTIES:
  :Effort:   3:00
  :END:
  :LOGBOOK:
  CLOCK: [2020-08-12 Wed 18:22]--[2020-08-12 Wed 18:43] =>  0:21
  :END:
  Leanr how to use the HtDW recipe to design interactive programs with atomic world state

** Overview
   Learn how to design interactive programs that use... drracket big bang functionality?
   Stuff like simple animations
   Also basic techniques for systemiatizing work on larger programs.
   Complemented by the Compound module (next) which will let us create more complex data definitions
   Apparently some of the videos are hella long
*** Learning goals
**** be able to explain the inherent structure of interactive graphical programs
**** be able to use the How to Design Worlds HtDW recipe to design interactive programs with atomic world state.
**** Be able to read and write big-bang expressions.
** Interactive Programs
*** will learn how to design simple interactive programs
    plain graphics but core structures will be like that of more sophisticated versions of the same program
**** animations
**** games
**** desktop applications
** The Big Bang Mechanism
   The inherent behind the scenes functionality of interactive programs
   The big-bang primitive
*** Big bang is a mechanism that supports interactive programs
*** Example programs
**** count down from 10 program, resets on space bar
***** changing state
****** the number on the screen
****** image displaying the number
****** both "tick" once per second
***** changing display
***** keyboard or mouse affects behavior
**** Cat moving left to right, resets on space bar
***** x position changes, thus position of cat image changes
***** Data:
****** numbers representing psoition of cat
       Cat is a number
       Interpret number to be x coordinate of a cat
       Simple Atomic Data
       Two functions:
       render-cat: takes a cat and returns an image of the cat at the appropriate position on the background
       next-cat: takes us from one cat to the next cat, in other words, advances cat's x position by 3

       0 (render-cat 0) (next-cat 0)
       3 (render-cat 3) (next-cat 3)
       6 (render-cat 6) (next-cat 6)
       9 (render-cat 9) (next-cat 9)
       To wire expresions together like this, dr racket uses big-bang expression
       Need an expression that evaluates to initial world state

       (big-bang 0              ; Cat
         (on-tick next-cat)     ; Cat -> Cat
         (to-draw render-cat))  ; Cat -> Image

       big-bang is polymorphic: works for any type of world state
       It's a user interface framework - a tool that integrates a bunch of functionality together to get a UI
* Compound Data (3 lectures, 4-6 hours)
  Leanr how to use the HtDW recipe to design interactive programs with compound world state
* Self-reference (7 lectures, 5-7 hours)
  Learn how to use well-formed self-referential data definitions to represent arbitrary sized data.
* Reference (3 lectures, 4-6 horus)
  Learn to predict and identify the correspondence between refercnes in a data definition and helper
function calls in functions that operate on the data
* Naturals (2 lectures, 3-4 horus)
  Design an alternate data defiition for the natural numbers, and learn to write function
using this new data definition
* Helpers (6 lectures, 6-9 hours)
  Learn a set of rules for desigining functions with helper functions
* Binary Search Trees (6 lectures, 5-6 hours)
  Design a data definition for Binary Search Trees, and learn to write functions operating
on BSTs
